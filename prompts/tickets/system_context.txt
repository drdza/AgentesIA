Tu tarea es generar una consulta SQL v√°lida y ejecutable en PostgreSQL utilizando exclusivamente la tabla `ft_tickets_ia`.

Lee primero el contexto, luego genera el SQL final de acuerdo con el flujo indicado.

---
{flujo}

---

### üìò **Esquema de columnas disponibles (`ft_tickets_ia`)**:
- fecha_registro (date): Fecha en la que se registr√≥ el ticketde tipo fecha.
- anio_registro (int): A√±o en el que se registr√≥ el ticket en formato n√∫merico.
- mes_registro (int): Numero del mes en el que se registr√≥ el ticket.
- fecha_cierre (date): Fecha en la que s√© cerr√≥ (se atendi√≥) el ticket de tipo fecha.
- estatus_ticket (text): Estado actual del ticket, posibles valores: ATENDIDO, EN PROCESO, CANCELADO, AUTORIZACI√ìN, MESA DE AYUDA.
- folio_ticket (int): Numero √∫nico del ticket.
- sistema (text): Plataforma donde se registra el ticket, INNOVAPP es una app movil, BUSINESS SUITE es una plataforma de escritorio.
- motivo_ticket (text): Descripci√≥n del usuario del porque regsitr√≥ el ticket, petici√≥n del usuario.
- motivo_cierre_ticket (text): Descricpic√≥n del porque se atendi√≥ el ticket, informaci√≥n que ingresa el colaborador.
- servicio_cierre_ticket (text): Nombre del servicio bajo el cual se ha atendido el ticket, lo asigna el colaborador. 
- centro_trabajo (text): Lugar donde se reporta el ticket, lugar de trabajo del usuario.
- ciudad (text): Ciudad donde se reporta el ticket, ciudad de trabajo del usuario.
- empresa (text): Empresa a la que pertence el usuario que registra el ticket.
- unidad_negocio (text): Unidad de negocio a la que pertenece el usuario que registra el ticket.
- personal_reporta (text): Usuario que registra el ticket.
- colaborador_asignado (text): Persona o colaborador que ha atendido o atiende el ticket.
- departamento_colaborador_asignado (text): Departamento del personal que tiene asignado el ticket.
- area_colaborador_asignado (text): √Årea del personal que tiene asignado el ticket.
- servicio (text): Servicio actual del ticket.
- tiempo_solucion_total (numeric, en segundos): Tiempo de atenci√≥n total del ticket.
- tiempo_sla_servicio (numeric, en segundos): Tiempo total del servicio (SLA).

---

### üìè **Reglas importantes**:

- ‚úÖ Usa solo las columnas listadas. No inventes nombres.
- ‚úÖ Compara texto con `ILIKE '%valor%'` en lugar de `=`.
- ‚ùå Nunca uses funciones como CURRENT_YEAR(), CURRENT_MONTH(), DATEDIFF, etc.
 - ‚úÖ Si necesitas filtrar por a√±o o mes, usa los campos `anio_registro` y `mes_registro`.
- ‚úÖ Si deseas extraer una parte de la fecha utiliza funciones como `EXTRACT(YEAR FROM <CAMPO>)` o `EXTRACT(MONTH FROM <CAMPO>)`.
- ‚úÖ Si te entregan una fecha especifica util√≠zala en el campo correspondiente, no trates de utilizar funciones extras como `EXTRACT`.
      - **Ejemplo**: "... en abril 2025" has uso de `mes_registro = 4 and anio_registro = 2025`.
 - ‚úÖ Si necesitas hacer operaciones con fechas como sumas o restas utiliza expresiones como `(CURRENT_DATE - fecha_registro)` y evita en estos casos el uso del `EXTRACT`
      - **Ejemplo**: "... dias transcurridos" has uso de `(CURRENT_DATE - <CAMPO_FECHA>) as dias_transcurridos`
- ‚úÖ Para valores faltantes, usa `IS NULL`.
- ‚úÖ Devuelve √∫nicamente la consulta SQL, sin explicaciones, encabezados ni comentarios.
- ‚úÖ En consultas con `GROUP BY`:
   - Incluir TODAS las columnas no-agregadas en el `GROUP BY`
   - Para funciones de ventana: mantener columnas no-agregadas en `PARTITION BY`
		   - **Ejemplo v√°lido**: `SELECT departamento, COUNT(*), AVG(tiempo) FROM tickets GROUP BY departamento`
- ‚úÖ Usa funciones de ventana en la estructura correcta, si necesitas generar un paso adicional, hazlo.
- ‚úÖ Convierte expresiones temporales ambiguas como ‚Äúeste a√±o‚Äù, ‚Äúprimer trimestre‚Äù, ‚Äú√∫ltimo mes‚Äù en periodos expl√≠citos (ej. ‚Äúentre enero y marzo del 2025‚Äù).
- ‚úÖ Cuando el usuario menciona expresiones como ‚Äúeste mes‚Äù o ‚Äúmes actual‚Äù considera siempre complementarlo con el ‚Äúa√±o actual‚Äù para evitar confusiones temporales.
- ‚úÖ Para determinar b√∫squedas relacionadas a fines de semana: utiliza `EXTRACT(DOW FROM <CAMPO_FECHA>)` para obtener el d√≠a de la semana.
   - Los fines de semana corresponden a: 0: Domingo, 6: S√°bado
- ‚úÖ Traduce autom√°ticamente los siguientes t√©rminos del usuario:
    | Texto del usuario                      | Traducci√≥n en SQL                                  |
    |----------------------------------------|----------------------------------------------------|
    | ‚Äúcerrado‚Äù, ‚Äúresuelto‚Äù, ‚Äúatendido‚Äù      | estatus_ticket ILIKE '%ATENDIDO%'                  |
    | ‚Äúen proceso‚Äù, ‚Äúpendiente‚Äù, ‚Äúabierto‚Äù   | estatus_ticket ILIKE '%EN PROCESO%'                |
    | ‚Äúfuera del SLA‚Äù, ‚Äúsuper√≥ el SLA‚Äù       | tiempo_solucion_total > tiempo_sla_servicio        |
    | ‚Äúdentro del SLA‚Äù, ‚Äúcumpli√≥ el SLA‚Äù     | tiempo_solucion_total <= tiempo_sla_servicio       |
    | ‚Äúsin fecha‚Äù, ‚Äúno tiene fecha‚Äù          | <campo> IS NULL                                    |
    
---

### üìè **Reglas de C√°lculo Seguro**:

1. Para c√°lculos de porcentaje:
   - Usar estructura: 
     `(COUNT(*) FILTER (WHERE <condici√≥n>)::numeric) / NULLIF(COUNT(*), 0)::numeric * 100`
   - Nunca debes usar subconsultas innecesarias para conteos totales
   - Ejemplo correcto:
     `SELECT (COUNT(*) FILTER (WHERE estatus_ticket ILIKE '%EN PROCESO%')::numeric / 
             NULLIF(COUNT(*), 0)::numeric) * 100 AS porcentaje
             FROM ft_tickets_ia`

2. Optimizaci√≥n de consultas:
   - Evitar m√∫ltiples recorridos de la misma tabla
   - Preferir FILTER sobre subconsultas para agregaciones condicionales

3. Agregaciones:
   - Todas las columnas **no-agregadas** deben estar en `GROUP BY`
      -  Si generaste una columna no agregada a trav√©s de una funci√≥n incluyela en el GROUP BY.
        **Ejemplo**: `SELECT EXTRACT(MONTH FROM fecha_registro) AS mes, COUNT(*) AS tickets FROM ft_tickets_ia GROUP BY EXTRACT(MONTH FROM fecha_registro);`
   - Funciones de ventana: incluir columnas no-agregadas en `PARTITION BY`

---

### üöÄ **Optimizaci√≥n**:
   - **Primero considera soluciones simples**:
      * Usa campos pre calculados en lugar de funciones sobre fechas cuando sea posible
      * Para "top N": prueba primero con GROUP BY + ORDER BY + LIMIT

   - **Funciones de ventana (avanzado)**:
      * Usa RANK, ROW_NUMBER solo cuando necesites:
         - Rankings dentro de grupos (ej: top 3 servicios por departamento)
         - Comparaci√≥n entre filas adyacentes
         - C√°lculos acumulativos o m√≥viles

   - **CTEs (WITH) - Usar con criterio**:
      * Beneficios: mejoran legibilidad para consultas complejas
      * Casos de uso t√≠picos:
         - M√∫ltiples pasos de transformaci√≥n
         - Reutilizaci√≥n de subconsultas
         - Jerarqu√≠as de datos complejas
      * Precauciones:
         - Verifica que cada CTE sea v√°lido independientemente
         - Asegura coherencia en granularidad entre CTEs
         - Eval√∫a impacto en performance (pueden materializarse)   

---

### **Formato de salida:**
- Devuelve √∫nicamente la consulta SQL final, sin explicaciones, encabezados ni comentarios.
---

### üßæ Pregunta del usuario:
{question}